{"ast":null,"code":"import _isFunction from \"lodash/isFunction\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nimport { mathSign, isNumber } from '../util/DataUtils';\nimport { getStringSize } from '../util/DOMUtils';\nimport { Global } from '../util/Global';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nimport { getAngledRectangleWidth } from '../util/CartesianUtils';\n/**\n * Given an array of ticks, find N, the lowest possible number for which every\n * nTH tick in the ticks array isShow == true and return the array of every nTh tick.\n * @param {CartesianTickItem[]} ticks An array of CartesianTickItem with the\n * information whether they can be shown without overlapping with their neighbour isShow.\n * @returns {CartesianTickItem[]} Every nTh tick in an array.\n */\n\nexport function getEveryNThTick(ticks) {\n  var N = 1;\n  var previous = getEveryNthWithCondition(ticks, N, function (tickItem) {\n    return tickItem.isShow;\n  });\n\n  while (N <= ticks.length) {\n    if (previous !== undefined) {\n      return previous;\n    }\n\n    N++;\n    previous = getEveryNthWithCondition(ticks, N, function (tickItem) {\n      return tickItem.isShow;\n    });\n  }\n\n  return ticks.slice(0, 1);\n}\nexport function getNumberIntervalTicks(ticks, interval) {\n  return getEveryNthWithCondition(ticks, interval + 1);\n}\n\nfunction getAngledTickWidth(contentSize, unitSize, angle) {\n  var size = {\n    width: contentSize.width + unitSize.width,\n    height: contentSize.height + unitSize.height\n  };\n  return getAngledRectangleWidth(size, angle);\n}\n\nfunction getTicksEnd(_ref) {\n  var angle = _ref.angle,\n      ticks = _ref.ticks,\n      tickFormatter = _ref.tickFormatter,\n      viewBox = _ref.viewBox,\n      orientation = _ref.orientation,\n      minTickGap = _ref.minTickGap,\n      unit = _ref.unit,\n      fontSize = _ref.fontSize,\n      letterSpacing = _ref.letterSpacing;\n  var x = viewBox.x,\n      y = viewBox.y,\n      width = viewBox.width,\n      height = viewBox.height;\n  var sizeKey = orientation === 'top' || orientation === 'bottom' ? 'width' : 'height'; // we need add the width of 'unit' only when sizeKey === 'width'\n\n  var unitSize = unit && sizeKey === 'width' ? getStringSize(unit, {\n    fontSize: fontSize,\n    letterSpacing: letterSpacing\n  }) : {\n    width: 0,\n    height: 0\n  };\n  var result = (ticks || []).slice();\n  var len = result.length;\n  var sign = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;\n  var start, end;\n\n  if (sign === 1) {\n    start = sizeKey === 'width' ? x : y;\n    end = sizeKey === 'width' ? x + width : y + height;\n  } else {\n    start = sizeKey === 'width' ? x + width : y + height;\n    end = sizeKey === 'width' ? x : y;\n  }\n\n  for (var i = len - 1; i >= 0; i--) {\n    var entry = result[i];\n    var content = _isFunction(tickFormatter) ? tickFormatter(entry.value, len - i - 1) : entry.value; // Recharts only supports angles when sizeKey === 'width'\n\n    var size = sizeKey === 'width' ? getAngledTickWidth(getStringSize(content, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    }), unitSize, angle) : getStringSize(content, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    })[sizeKey];\n\n    if (i === len - 1) {\n      var gap = sign * (entry.coordinate + sign * size / 2 - end);\n      result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n        tickCoord: gap > 0 ? entry.coordinate - gap * sign : entry.coordinate\n      });\n    } else {\n      result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n        tickCoord: entry.coordinate\n      });\n    }\n\n    var isShow = sign * (entry.tickCoord - sign * size / 2 - start) >= 0 && sign * (entry.tickCoord + sign * size / 2 - end) <= 0;\n\n    if (isShow) {\n      end = entry.tickCoord - sign * (size / 2 + minTickGap);\n      result[i] = _objectSpread(_objectSpread({}, entry), {}, {\n        isShow: true\n      });\n    }\n  }\n\n  return result;\n}\n\nfunction getTicksStart(_ref2, preserveEnd) {\n  var angle = _ref2.angle,\n      ticks = _ref2.ticks,\n      tickFormatter = _ref2.tickFormatter,\n      viewBox = _ref2.viewBox,\n      orientation = _ref2.orientation,\n      minTickGap = _ref2.minTickGap,\n      unit = _ref2.unit,\n      fontSize = _ref2.fontSize,\n      letterSpacing = _ref2.letterSpacing;\n  var x = viewBox.x,\n      y = viewBox.y,\n      width = viewBox.width,\n      height = viewBox.height;\n  var sizeKey = orientation === 'top' || orientation === 'bottom' ? 'width' : 'height';\n  var result = (ticks || []).slice(); // we need add the width of 'unit' only when sizeKey === 'width'\n\n  var unitSize = unit && sizeKey === 'width' ? getStringSize(unit, {\n    fontSize: fontSize,\n    letterSpacing: letterSpacing\n  }) : {\n    width: 0,\n    height: 0\n  };\n  var len = result.length;\n  var sign = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;\n  var start, end;\n\n  if (sign === 1) {\n    start = sizeKey === 'width' ? x : y;\n    end = sizeKey === 'width' ? x + width : y + height;\n  } else {\n    start = sizeKey === 'width' ? x + width : y + height;\n    end = sizeKey === 'width' ? x : y;\n  }\n\n  if (preserveEnd) {\n    // Try to guarantee the tail to be displayed\n    var tail = ticks[len - 1];\n    var tailContent = _isFunction(tickFormatter) ? tickFormatter(tail.value, len - 1) : tail.value; // Recharts only supports angles when sizeKey === 'width'\n\n    var tailSize = sizeKey === 'width' ? getAngledTickWidth(getStringSize(tailContent, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    }), unitSize, angle) : getStringSize(tailContent, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    })[sizeKey];\n    var tailGap = sign * (tail.coordinate + sign * tailSize / 2 - end);\n    result[len - 1] = tail = _objectSpread(_objectSpread({}, tail), {}, {\n      tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign : tail.coordinate\n    });\n    var isTailShow = sign * (tail.tickCoord - sign * tailSize / 2 - start) >= 0 && sign * (tail.tickCoord + sign * tailSize / 2 - end) <= 0;\n\n    if (isTailShow) {\n      end = tail.tickCoord - sign * (tailSize / 2 + minTickGap);\n      result[len - 1] = _objectSpread(_objectSpread({}, tail), {}, {\n        isShow: true\n      });\n    }\n  }\n\n  var count = preserveEnd ? len - 1 : len;\n\n  for (var i = 0; i < count; i++) {\n    var entry = result[i];\n    var content = _isFunction(tickFormatter) ? tickFormatter(entry.value, i) : entry.value;\n    var size = sizeKey === 'width' ? getAngledTickWidth(getStringSize(content, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    }), unitSize, angle) : getStringSize(content, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    })[sizeKey];\n\n    if (i === 0) {\n      var gap = sign * (entry.coordinate - sign * size / 2 - start);\n      result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n        tickCoord: gap < 0 ? entry.coordinate - gap * sign : entry.coordinate\n      });\n    } else {\n      result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n        tickCoord: entry.coordinate\n      });\n    }\n\n    var isShow = sign * (entry.tickCoord - sign * size / 2 - start) >= 0 && sign * (entry.tickCoord + sign * size / 2 - end) <= 0;\n\n    if (isShow) {\n      start = entry.tickCoord + sign * (size / 2 + minTickGap);\n      result[i] = _objectSpread(_objectSpread({}, entry), {}, {\n        isShow: true\n      });\n    }\n  }\n\n  return result;\n}\n\nexport function getTicks(props, fontSize, letterSpacing) {\n  var tick = props.tick,\n      ticks = props.ticks,\n      viewBox = props.viewBox,\n      minTickGap = props.minTickGap,\n      orientation = props.orientation,\n      interval = props.interval,\n      tickFormatter = props.tickFormatter,\n      unit = props.unit,\n      angle = props.angle;\n\n  if (!ticks || !ticks.length || !tick) {\n    return [];\n  }\n\n  if (isNumber(interval) || Global.isSsr) {\n    return getNumberIntervalTicks(ticks, typeof interval === 'number' && isNumber(interval) ? interval : 0);\n  }\n\n  var candidates = [];\n\n  if (interval === 'equidistantPreserveStart') {\n    candidates = getTicksStart({\n      angle: angle,\n      ticks: ticks,\n      tickFormatter: tickFormatter,\n      viewBox: viewBox,\n      orientation: orientation,\n      minTickGap: minTickGap,\n      unit: unit,\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    });\n    return getEveryNThTick(candidates);\n  }\n\n  if (interval === 'preserveStart' || interval === 'preserveStartEnd') {\n    candidates = getTicksStart({\n      angle: angle,\n      ticks: ticks,\n      tickFormatter: tickFormatter,\n      viewBox: viewBox,\n      orientation: orientation,\n      minTickGap: minTickGap,\n      unit: unit,\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    }, interval === 'preserveStartEnd');\n  } else {\n    candidates = getTicksEnd({\n      angle: angle,\n      ticks: ticks,\n      tickFormatter: tickFormatter,\n      viewBox: viewBox,\n      orientation: orientation,\n      minTickGap: minTickGap,\n      unit: unit,\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    });\n  }\n\n  return candidates.filter(function (entry) {\n    return entry.isShow;\n  });\n}","map":{"version":3,"sources":["/workspaces/Glocafe1/node_modules/recharts/es6/cartesian/getTicks.js"],"names":["_isFunction","_typeof","obj","Symbol","iterator","constructor","prototype","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","value","_toPropertyKey","configurable","writable","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","TypeError","Number","mathSign","isNumber","getStringSize","Global","getEveryNthWithCondition","getAngledRectangleWidth","getEveryNThTick","ticks","N","previous","tickItem","isShow","slice","getNumberIntervalTicks","interval","getAngledTickWidth","contentSize","unitSize","angle","size","width","height","getTicksEnd","_ref","tickFormatter","viewBox","orientation","minTickGap","unit","fontSize","letterSpacing","x","y","sizeKey","result","len","sign","coordinate","start","end","entry","content","gap","tickCoord","getTicksStart","_ref2","preserveEnd","tail","tailContent","tailSize","tailGap","isTailShow","count","getTicks","props","tick","isSsr","candidates"],"mappings":"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","sourcesContent":["import _isFunction from \"lodash/isFunction\";\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { mathSign, isNumber } from '../util/DataUtils';\nimport { getStringSize } from '../util/DOMUtils';\nimport { Global } from '../util/Global';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nimport { getAngledRectangleWidth } from '../util/CartesianUtils';\n\n/**\n * Given an array of ticks, find N, the lowest possible number for which every\n * nTH tick in the ticks array isShow == true and return the array of every nTh tick.\n * @param {CartesianTickItem[]} ticks An array of CartesianTickItem with the\n * information whether they can be shown without overlapping with their neighbour isShow.\n * @returns {CartesianTickItem[]} Every nTh tick in an array.\n */\nexport function getEveryNThTick(ticks) {\n  var N = 1;\n  var previous = getEveryNthWithCondition(ticks, N, function (tickItem) {\n    return tickItem.isShow;\n  });\n  while (N <= ticks.length) {\n    if (previous !== undefined) {\n      return previous;\n    }\n    N++;\n    previous = getEveryNthWithCondition(ticks, N, function (tickItem) {\n      return tickItem.isShow;\n    });\n  }\n  return ticks.slice(0, 1);\n}\nexport function getNumberIntervalTicks(ticks, interval) {\n  return getEveryNthWithCondition(ticks, interval + 1);\n}\nfunction getAngledTickWidth(contentSize, unitSize, angle) {\n  var size = {\n    width: contentSize.width + unitSize.width,\n    height: contentSize.height + unitSize.height\n  };\n  return getAngledRectangleWidth(size, angle);\n}\nfunction getTicksEnd(_ref) {\n  var angle = _ref.angle,\n    ticks = _ref.ticks,\n    tickFormatter = _ref.tickFormatter,\n    viewBox = _ref.viewBox,\n    orientation = _ref.orientation,\n    minTickGap = _ref.minTickGap,\n    unit = _ref.unit,\n    fontSize = _ref.fontSize,\n    letterSpacing = _ref.letterSpacing;\n  var x = viewBox.x,\n    y = viewBox.y,\n    width = viewBox.width,\n    height = viewBox.height;\n  var sizeKey = orientation === 'top' || orientation === 'bottom' ? 'width' : 'height';\n  // we need add the width of 'unit' only when sizeKey === 'width'\n  var unitSize = unit && sizeKey === 'width' ? getStringSize(unit, {\n    fontSize: fontSize,\n    letterSpacing: letterSpacing\n  }) : {\n    width: 0,\n    height: 0\n  };\n  var result = (ticks || []).slice();\n  var len = result.length;\n  var sign = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;\n  var start, end;\n  if (sign === 1) {\n    start = sizeKey === 'width' ? x : y;\n    end = sizeKey === 'width' ? x + width : y + height;\n  } else {\n    start = sizeKey === 'width' ? x + width : y + height;\n    end = sizeKey === 'width' ? x : y;\n  }\n  for (var i = len - 1; i >= 0; i--) {\n    var entry = result[i];\n    var content = _isFunction(tickFormatter) ? tickFormatter(entry.value, len - i - 1) : entry.value;\n    // Recharts only supports angles when sizeKey === 'width'\n    var size = sizeKey === 'width' ? getAngledTickWidth(getStringSize(content, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    }), unitSize, angle) : getStringSize(content, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    })[sizeKey];\n    if (i === len - 1) {\n      var gap = sign * (entry.coordinate + sign * size / 2 - end);\n      result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n        tickCoord: gap > 0 ? entry.coordinate - gap * sign : entry.coordinate\n      });\n    } else {\n      result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n        tickCoord: entry.coordinate\n      });\n    }\n    var isShow = sign * (entry.tickCoord - sign * size / 2 - start) >= 0 && sign * (entry.tickCoord + sign * size / 2 - end) <= 0;\n    if (isShow) {\n      end = entry.tickCoord - sign * (size / 2 + minTickGap);\n      result[i] = _objectSpread(_objectSpread({}, entry), {}, {\n        isShow: true\n      });\n    }\n  }\n  return result;\n}\nfunction getTicksStart(_ref2, preserveEnd) {\n  var angle = _ref2.angle,\n    ticks = _ref2.ticks,\n    tickFormatter = _ref2.tickFormatter,\n    viewBox = _ref2.viewBox,\n    orientation = _ref2.orientation,\n    minTickGap = _ref2.minTickGap,\n    unit = _ref2.unit,\n    fontSize = _ref2.fontSize,\n    letterSpacing = _ref2.letterSpacing;\n  var x = viewBox.x,\n    y = viewBox.y,\n    width = viewBox.width,\n    height = viewBox.height;\n  var sizeKey = orientation === 'top' || orientation === 'bottom' ? 'width' : 'height';\n  var result = (ticks || []).slice();\n  // we need add the width of 'unit' only when sizeKey === 'width'\n  var unitSize = unit && sizeKey === 'width' ? getStringSize(unit, {\n    fontSize: fontSize,\n    letterSpacing: letterSpacing\n  }) : {\n    width: 0,\n    height: 0\n  };\n  var len = result.length;\n  var sign = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;\n  var start, end;\n  if (sign === 1) {\n    start = sizeKey === 'width' ? x : y;\n    end = sizeKey === 'width' ? x + width : y + height;\n  } else {\n    start = sizeKey === 'width' ? x + width : y + height;\n    end = sizeKey === 'width' ? x : y;\n  }\n  if (preserveEnd) {\n    // Try to guarantee the tail to be displayed\n    var tail = ticks[len - 1];\n    var tailContent = _isFunction(tickFormatter) ? tickFormatter(tail.value, len - 1) : tail.value;\n    // Recharts only supports angles when sizeKey === 'width'\n    var tailSize = sizeKey === 'width' ? getAngledTickWidth(getStringSize(tailContent, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    }), unitSize, angle) : getStringSize(tailContent, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    })[sizeKey];\n    var tailGap = sign * (tail.coordinate + sign * tailSize / 2 - end);\n    result[len - 1] = tail = _objectSpread(_objectSpread({}, tail), {}, {\n      tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign : tail.coordinate\n    });\n    var isTailShow = sign * (tail.tickCoord - sign * tailSize / 2 - start) >= 0 && sign * (tail.tickCoord + sign * tailSize / 2 - end) <= 0;\n    if (isTailShow) {\n      end = tail.tickCoord - sign * (tailSize / 2 + minTickGap);\n      result[len - 1] = _objectSpread(_objectSpread({}, tail), {}, {\n        isShow: true\n      });\n    }\n  }\n  var count = preserveEnd ? len - 1 : len;\n  for (var i = 0; i < count; i++) {\n    var entry = result[i];\n    var content = _isFunction(tickFormatter) ? tickFormatter(entry.value, i) : entry.value;\n    var size = sizeKey === 'width' ? getAngledTickWidth(getStringSize(content, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    }), unitSize, angle) : getStringSize(content, {\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    })[sizeKey];\n    if (i === 0) {\n      var gap = sign * (entry.coordinate - sign * size / 2 - start);\n      result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n        tickCoord: gap < 0 ? entry.coordinate - gap * sign : entry.coordinate\n      });\n    } else {\n      result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n        tickCoord: entry.coordinate\n      });\n    }\n    var isShow = sign * (entry.tickCoord - sign * size / 2 - start) >= 0 && sign * (entry.tickCoord + sign * size / 2 - end) <= 0;\n    if (isShow) {\n      start = entry.tickCoord + sign * (size / 2 + minTickGap);\n      result[i] = _objectSpread(_objectSpread({}, entry), {}, {\n        isShow: true\n      });\n    }\n  }\n  return result;\n}\nexport function getTicks(props, fontSize, letterSpacing) {\n  var tick = props.tick,\n    ticks = props.ticks,\n    viewBox = props.viewBox,\n    minTickGap = props.minTickGap,\n    orientation = props.orientation,\n    interval = props.interval,\n    tickFormatter = props.tickFormatter,\n    unit = props.unit,\n    angle = props.angle;\n  if (!ticks || !ticks.length || !tick) {\n    return [];\n  }\n  if (isNumber(interval) || Global.isSsr) {\n    return getNumberIntervalTicks(ticks, typeof interval === 'number' && isNumber(interval) ? interval : 0);\n  }\n  var candidates = [];\n  if (interval === 'equidistantPreserveStart') {\n    candidates = getTicksStart({\n      angle: angle,\n      ticks: ticks,\n      tickFormatter: tickFormatter,\n      viewBox: viewBox,\n      orientation: orientation,\n      minTickGap: minTickGap,\n      unit: unit,\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    });\n    return getEveryNThTick(candidates);\n  }\n  if (interval === 'preserveStart' || interval === 'preserveStartEnd') {\n    candidates = getTicksStart({\n      angle: angle,\n      ticks: ticks,\n      tickFormatter: tickFormatter,\n      viewBox: viewBox,\n      orientation: orientation,\n      minTickGap: minTickGap,\n      unit: unit,\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    }, interval === 'preserveStartEnd');\n  } else {\n    candidates = getTicksEnd({\n      angle: angle,\n      ticks: ticks,\n      tickFormatter: tickFormatter,\n      viewBox: viewBox,\n      orientation: orientation,\n      minTickGap: minTickGap,\n      unit: unit,\n      fontSize: fontSize,\n      letterSpacing: letterSpacing\n    });\n  }\n  return candidates.filter(function (entry) {\n    return entry.isShow;\n  });\n}"]},"metadata":{},"sourceType":"module"}